---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-09-03              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P944 删列造序

给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。

删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。

比如，有 A = ["abcdef", "uvwxyz"]，

要删掉的列为 `{0, 2, 3}`，删除后 `A` 为`["bef", "vyz"]`， `A` 的列分别为`["b","v"], ["e","y"], ["f","z"]`。

你需要选出一组要删掉的列 `D`，对 `A` 执行删除操作，使 `A` 中剩余的每一列都是 **非降序** 排列的，然后请你返回 `D.length` 的最小可能值。


实例：

```
输入：["cba", "daf", "ghi"]
输出：1
解释：
当选择 D = {1}，删除后 A 的列为：["c","d","g"] 和 ["a","f","i"]，均为非降序排列。
若选择 D = {}，那么 A 的列 ["b","a","h"] 就不是非降序排列了。

输入：["a", "b"]
输出：0
解释：D = {}

输入：["zyx", "wvu", "tsr"]
输出：3
解释：D = {0, 1, 2}
```

### 思路

* 题目很绕，其实很简单，字符串一行行摆好，一列列的比较，上一行字母不能大于下一行字母，否则这一列就是需要删除的，记录所需i删除的列数。

### Solution

```c++
class Solution {
public:
    int minDeletionSize(vector<string>& A) {
        int l = A[0].length(), n = A.size(), count = 0;
        for(int i=0;i<l;i++){
            for(int j=0;j<n-1;j++){
                if(A[j][i]>A[j+1][i]){
                    count++;
                    break;
                }
            }
        }
        return count;
    }
};
```

## P559 N叉树的最大深度

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

示例:

```
无
```

### 思路

* 递归

### Solution

```
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/
class Solution {
public:
    int maxDepth(Node* root) {
    if (!root) return 0;
    int m = 0;
    for (Node* it : root->children) 
        m = max(m, maxDepth(it));
    return ++m;
	}
};
```

