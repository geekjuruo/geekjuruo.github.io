---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-26              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1036 选数

题目描述：

已知n 个整数x1,x2,…,xn，以及1个整数k(k<n)。从n个整数中任选k个整数相加，可分别得到一系列的和。例如n=4,k=3,4个整数分别为3,7,12,19时，可得全部的组合与它们的和为：
$$
\begin{array}{l}{3+7+12=22} \\ {3+7+19=29} \\ {7+12+19=38} \\ {3+12+19=34}\end{array}
$$
现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：3+7+19=29。

输入格式：
$$
\begin{array}{l}{n, k(1 \leq n \leq 20, k<n)} \\ {x_{1}, x_{2}, \ldots, x_{n}\left(1 \leq x_{i} \leq 5000000\right)}\end{array}
$$
输出格式：

1个整数（满足条件的种数）

实例：

```
4 3
3 7 12 19

1
```

### 思路

* 这道题的关键在于如何列出所有的选数组合，那么自然想到递归。我们将n个数存入数组num[]中，选数过程可以看作是从下标0～n-1中选择不重复的k个填满k个空位。函数dfs()中sum记录当前已选数的累加和，left记录当前剩余空位数，p指出当前空位可以从num[]中哪一位下标开始选。由于组合是无序的，且不能选择重复的数，所以要遵循从前往后选数的规则，即后一个空位只能选择num[]中下标比前一个空位所选数下标大的数。另一方面，还必须保证后面所有的空位都至少有一个选择，所以当前空位所选数的下标最大只能是n-left。因此p～n-left都是当前可能的选择，遍历所有可能递归调用dfs()进行下一个空位的选择即可。直到left为0，说明已无空位，判定当前的sum是否为素数然后退出。 


### Solution

```c++
#include <stdio.h>

int n, k, cnt;
int num[25];

int isPrime(int n)
{
    for (int i = 2; i * i <= n; i++)
        if (n % i == 0)
            return 0;
    return 1;
}

void dfs(int sum, int p, int left)
{
    if (!left)
    {
        if (isPrime(sum))
            cnt++;
        return;
    }
    for (int i = p; i <= n - left; i++)
        dfs(sum + num[i], i + 1, left - 1);
}

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++)
        scanf("%d", &num[i]);
    dfs(0, 0, k);
    printf("%d\n", cnt);
    return 0;
}
```

## 附

递归取数（排列）

从n个数中选取k个数

```
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
vector<int> a;
vector<int> b;
void fun(int a)
{
	cout << a << " ";
}
void show(vector<int> a)
{
	for_each(a.begin(),a.end(),fun);
	cout << endl;
}

//这个函数的功能是求从数组a的n个数中选出k个数放到数组b之中
void nchoosek(int n,int k)
{
	int i;
	if(k==0)
	{
		show(b);
	}
	else
	{   
		//这个地方i是下标
		for(i=k-1;i<=n-1;i++)
		{
			//确定倒数第一个数
			b[k-1]=a[i];
			//大问题转化为小问题
			//这个地方的i是小问题n的规模
			//二者的意义是不一样的，切记
			nchoosek(i,k-1);
		}
	}
}

void nchoosek_wrap(int n,int k)
{
	sort(a.begin(),a.end());
	nchoosek(n,k);
}

int main()
{
	int n,k;
	cin >> n >> k;
    a.resize(n);
    b.resize(k);
	for(int i=0;i<n;i++)
	{
		cin >> a[i];
	}
	nchoosek_wrap(n,k);
	return 0;
}
```

