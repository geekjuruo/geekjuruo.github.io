---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-07-24              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1005 矩阵取数游戏

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的n×m的矩阵，矩阵中的每个元素ai,j均为非负整数。游戏规则如下：

* 每次取数时须从每行各取走一个元素，共n个。经过m次后取完矩阵内所有元素

* 每次取走的各个元素只能是该元素所在行的行首或行尾；

* 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值×2^i，其中i表示第i次取数（从1开始编号）；

* 游戏结束总得分为m次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。

输入格式：

输入文件包括n+1行：

第1行为两个用空格隔开的整数n和m。

第2∽n+1行为n×m矩阵，其中每行有m个用单个空格隔开的非负整数。

输出格式：

输出文件仅包含1行，为一个整数，即输入矩阵取数后的最大得分。

示例:

```
输入: 
2 3
1 2 3
3 4 2
输出:
82

```

### 思路

* 求nn行最大得分和，每一行取数又不会影响到其他行，那么只要确保每一行得分最大，管好自家孩子就行了。（这个在动规中叫**最优子结构**）
* 每次取数是在边缘取，那么每次取数完剩下来的元素一定是在一个完整的一个区间中，又是求最优解，**区间DP**应运而生。

## DP流程

(每次DP仅针对第TT行)

### 状态

- 我们用fi,jfi,j表示区间变为\[i,j]时，获得的最大分数。

### 转移

- 当区间变为\[i,j]时，上一次取数的时候区间一定是\[i−1,j]或\[i,j+1]，从这两个状态转移即可。在第m−j+i−1次(这个请自行模拟)取走了Ai−1,j或Ai,j+1即：
  $$
  f_{i, j}=\max \left\{f_{i-1, j}+A_{i-1, j} \cdot 2^{m-j+i-1}, f_{i, j+1}+A_{i, j+1} \cdot 2^{m-j+i-1}\right\}
  $$


### 终值（答案）

- 啊这个终值超级讨厌，状态不明确的话还真想不出来。

- ## 因为题目中说要取完，但是空区间是DP不出来的，然后就得手动模拟每个长度为11的区间。即：

  $$
  A n s=m a x_{i \leq m}\left\{f_{i, i}+A_{i, i} \cdot 2^{m}\right\}
  $$


* **高精度**

### Solution

```java
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>

using namespace std;

const int MAXN = 85, Mod = 10000; //高精四位压缩大法好 
int n, m;
int ar[MAXN];

struct HP {
    int p[505], len;
    HP() {
        memset(p, 0, sizeof p);
        len = 0;
    } //这是构造函数，用于直接创建一个高精度变量 
    void print() {
        printf("%d", p[len]);  
        for (int i = len - 1; i > 0; i--) {  
            if (p[i] == 0) {
                printf("0000"); 
                continue;
            }
            for (int k = 10; k * p[i] < Mod; k *= 10) 
                printf("0");
            printf("%d", p[i]);
        }
    } //四位压缩的输出 
} f[MAXN][MAXN], base[MAXN], ans;

HP operator + (const HP &a, const HP &b) {
    HP c; c.len = max(a.len, b.len); int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] + b.p[i] + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    if (x > 0)
        c.p[++c.len] = x;
    return c;
} //高精+高精 

HP operator * (const HP &a, const int &b) {
    HP c; c.len = a.len; int x = 0;
    for (int i = 1; i <= c.len; i++) {
        c.p[i] = a.p[i] * b + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    while (x > 0)
        c.p[++c.len] = x % Mod, x /= Mod;
    return c;
} //高精*单精 

HP max(const HP &a, const HP &b) {
    if (a.len > b.len)
        return a;
    else if (a.len < b.len)
        return b;
    for (int i = a.len; i > 0; i--)
        if (a.p[i] > b.p[i])
            return a;
        else if (a.p[i] < b.p[i])
            return b;
    return a;
} //比较取最大值 

void BaseTwo() {
    base[0].p[1] = 1, base[0].len = 1;
    for (int i = 1; i <= m + 2; i++){ //这里是m! m! m! 我TM写成n调了n年... 
        base[i] = base[i - 1] * 2;
    }
} //预处理出2的幂 

int main(void) {
    scanf("%d%d", &n, &m);
    BaseTwo();
    while (n--) {
        memset(f, 0, sizeof f);
        for (int i = 1; i <= m; i++)
            scanf("%d", &ar[i]);
        for (int i = 1; i <= m; i++)
            for (int j = m; j >= i; j--) { //因为终值是小区间，DP自然就从大区间开始 
                f[i][j] = max(f[i][j], f[i - 1][j] + base[m - j + i - 1] * ar[i - 1]); 
                f[i][j] = max(f[i][j], f[i][j + 1] + base[m - j + i - 1] * ar[j + 1]);
            } //用结构体重载运算符写起来比较自然 
        HP Max;
        for (int i = 1; i <= m; i++)
            Max = max(Max, f[i][i] + base[m] * ar[i]);
        ans = ans + Max; //记录到总答案中 
    }
    ans.print(); //输出 
    return 0;
}
```


