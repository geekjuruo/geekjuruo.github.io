---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-29              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1039 侦探推理

题目描述：

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

证词中出现的其他话，都不列入逻辑推理的内容。

明明所知道的是，他的同学中有NN个人始终说假话，其余的人始终说真。

现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

输入格式：

输入由若干行组成，第一行有三个整数，M(1≤M≤20)、N(1≤N≤M)和P(1≤P≤100)；M是参加游戏的明明的同学数，N是其中始终说谎的人数，P是证言的总数。

接下来M行，每行是明明的一个同学的名字（英文字母组成，没有空格，全部大写）。

往后有P行，每行开始是某个同学的名宇，紧跟着一个冒号和一个空格，后面是一句证词，符合前表中所列格式。证词每行不会超过250个字符。

输入中不会出现连续的两个空格，而且每行开头和结尾也没有空格。

输出格式：

如果你的程序能确定谁是罪犯，则输出他的名字；如果程序判断出不止一个人可能是罪犯，则输出 "Cannot Determine"；如果程序判断出没有人可能成为罪犯，则输出 "Impossible"。

输入输出样例：

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??、

MIKE
```

### 思路

* 根据题意可知可以利用枚举法完成。枚举罪犯和今天是星期几。满足N个人始终说谎话和M-N个人始终说真话的条件，就可以确定罪犯。

* 首先利用字符串操作将证言转化成计算机可表示的信息。

* 说话者的内容：

  ```
   "Today is Monday.",    //0
   "Today is Tuesday.",   //1
   "Today is Wednesday.", //2
   "Today is Thursday.",  //3
   "Today is Friday.",    //4
   "Today is Saturday.",  //5 
   "Today is Sunday.",    //6
   "I am guilty.",        //7
   "I am not guilty.",    //8
   "is guilty.",          //9
   "is not guilty.",      //10
  ```



### Solution

```c++
#include <bits/stdc++.h>
using namespace std ;
const int M = 20 ;
const int P = 100 ;
const int L = 300 ;
char Says[30][300]=
{ //一共11中说话类型 
    "Today is Monday.",    //0
    "Today is Tuesday.",   //1
    "Today is Wednesday.", //2
    "Today is Thursday.",  //3
    "Today is Friday.",    //4
    "Today is Saturday.",  //5 
    "Today is Sunday.",    //6
    "I am guilty.",        //7
    "I am not guilty.",    //8
    "is guilty.",          //9
    "is not guilty.",      //10
} ;
char talk[P],name[M][L],who[P][L],guilty[P][L],sayswhat[P][L] ;
bool liar[M] ;
vector<pair<int,int> > vec[M] ;
int m,n,p ;
bool same(char a[],char b[]) { //判断两个字符串是否相同 
    if (strlen(a)!=strlen(b)) return false ;
    for (int i=0;i<strlen(a);i++) if (a[i]!=b[i]) return false ;
    return true;    
}
int search(char s[],char b){
    for (int i=0;i<strlen(s);i++) if (s[i]==b) return i ;
}
bool lie(int i,int j,int d,int x){
    if (vec[i][j].first>=0 && vec[i][j].first<=6){
        if (vec[i][j].first!=d) return true ;
    }
    else if (vec[i][j].first==7){
        if (i!=x) return true  ;
    }
    else if (vec[i][j].first==8){
        if (i==x) return true ;
    }
    else if (vec[i][j].first==9){
        if (vec[i][j].second!=x) return true  ;
    }
    else if (vec[i][j].first==10){
        if (vec[i][j].second==x) return true ;
    }
    return false ;
}
bool judge(int d,int x){
    int nosay=0 ;
    memset(liar,false,sizeof(liar)) ;//所有人都不是liar  
    for (int i=1;i<=m;i++){
        if (vec[i].empty()) nosay++ ; 
        else
        {
            liar[i]=lie(i,0,d,x) ;
            for (int j=1;j<vec[i].size();j++){
                bool bf=lie(i,j,d,x);
                if (bf!=liar[i]) return false ;
                liar[i]=bf ;
            }
        } 
    }
    int liesum=0;
    for (int i=1;i<=m;i++) if (liar[i]) liesum++ ;
    if (liesum+nosay==n || liesum==n) return true ;
    else return false ;
}
int main(){
    scanf("%d%d%d\n",&m,&n,&p) ;
    for (int i=1;i<=m;i++) {
        gets(name[i]);//他的名字 
        name[i][strlen(name[i])-1]='\0' ;
    }
    for (int i=1;i<=p;i++){
        int id ;
        gets(talk) ;
        talk[strlen(talk)-1]='\0' ;
        int pos;
        pos=search(talk,':') ;//先查询，每个人的名字 
        strncpy(who[i],talk,pos) ;
        for (int j=1;j<=m;j++) //说话者的编号 
        if (same(who[i],name[j])){ 
            id=j ;
            break ;
        }
        strncpy(sayswhat[i],talk+pos+2,strlen(talk)) ;
        int f=false ;
        for (int j=0;j<=8;j++){ //他说的话的种类 
            if (same(sayswhat[i],Says[j])){
                if (j>=0 && j<=6) vec[id].push_back(make_pair(j,0)) ;//星期 
                else if (j==7 || j==8) vec[id].push_back(make_pair(j,0)) ;//我的信息 
                f=true ;
                break ;
            }
        }
        if (!f)
        for (int j=9;j<=10;j++){
            char *pos ;
            pos=strstr(sayswhat[i],Says[j]) ;
            if (pos!=NULL){
                strncpy(guilty[i],sayswhat[i],pos-sayswhat[i]-1) ;
                int ID ;
                for (int k=1;k<=m;k++) //说话者的编号 
                if (same(guilty[i],name[k])){ 
                    ID=k ;
                    break ;
                }
                vec[id].push_back(make_pair(j,ID)) ;//别人的信息 
            }
        }
    }
    int ans=-1 ;
    for (int j=1;j<=m;j++){
        bool f=false;
        for (int i=0;i<=6;i++){
            bool ok=judge(i,j) ;
            if (ok){
                if (ans==-1 && !f) {
                    ans=j ;
                    f=true; 
                    break;
                }
                else if (ans!=-1) {
                    printf("Cannot Determine\n") ;
                    return 0 ;
                }
            }
        }
    }
    if (ans==-1) printf("Impossible\n") ;
    else printf("%s\n",name[ans]) ;
}
```



