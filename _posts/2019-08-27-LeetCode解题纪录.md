---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-27              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P977 有序数组的平方

给定一个按非递减顺序排序的整数数组 `A`，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。

实例：

```
输入：[-4,-1,0,3,10]
输出：[0,1,9,16,100]

输入：[-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

### 思路

* 平方再排序为常规做法，不过忽略了有序条件

  由于数组有序，较大平方必然位于两侧，故而采用双指针法，一头一尾，遇到较大平方则插入并移动指针


### Solution

```c++
class Solution {
public:
	vector<int> sortedSquares(vector<int>& A) {
		int length = A.size();
		vector<int> ans(length);
		int i = 0, j = length - 1,k = length - 1;
		while (k >= 0) {
			int a = A[i] * A[i];
			int b = A[j] * A[j];
			if (a > b) {
				ans[k] = a;
				i++;
			}
			else {
				ans[k] = b;
				j--;
			}
			k--;
		}
		return ans;
	}
};
```

## P104 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

示例:

```
给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
   
返回它的最大深度 3 
```

### 思路

* 递归累加求最大深度

### Solution

```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // 当根结点为空
        if(root == NULL) {
            return 0;
        }
        // 当左右节点均为空（叶子节点），返回1
        if((root->left == NULL) && (root->right == NULL)) {
            return 1;
        }
        // 递归：每个根节点的最大深度=左右节点最大深度的最大值  +  1 ，这里在累加
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

