---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-2-1              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## 2.1 在二叉树中分配硬币

- 给定一个有 `N` 个结点的二叉树的根结点 `root`，树中的每个结点上都对应有 `node.val`枚硬币，并且总共有 `N` 枚硬币。

  在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。

  返回使每个结点上只有一枚硬币所需的移动次数。



### 思路

#### 方法一：深度优先遍历

**思路**

如果树的叶子仅包含 0 枚金币（与它所需相比，它的 `过载量` 为 -1），那么我们需要从它的父亲节点移动一枚金币到这个叶子节点上。如果说，一个叶子节点包含 4 枚金币（它的 `过载量` 为 3），那么我们需要将这个叶子节点中的 3 枚金币移动到别的地方去。总的来说，对于一个叶子节点，需要移动到它中或需要从它移动到它的父亲中的金币数量为 `过载量 = Math.abs(num_coins - 1)`。然后，在接下来的计算中，我们就再也不需要考虑这些已经考虑过的叶子节点了。

**算法**

我们可以用上述的方法来逐步构建我们的最终答案。定义 `dfs(node)` 为这个节点所在的子树中金币的 *过载量*，也就是这个子树中金币的数量减去这个子树中节点的数量。接着，我们可以计算出这个节点与它的子节点之间需要移动金币的数量为 `abs(dfs(node.left)) + abs(dfs(node.right))`，这个节点金币的过载量为 `node.val + dfs(node.left) + dfs(node.right) - 1`。



### Solution

```c++
class Solution {
    int ans;
    public int distributeCoins(TreeNode root) {
        ans = 0;
        dfs(root);
        return ans;
    }

    public int dfs(TreeNode node) {
        if (node == null) return 0;
        int L = dfs(node.left);
        int R = dfs(node.right);
        ans += Math.abs(L) + Math.abs(R);
        return node.val + L + R - 1;
    }
}
```



## 2.1 煎饼排序

给定数组 `A`，我们可以对其进行*煎饼翻转*：我们选择一些正整数 `k <= A.length`，然后反转 `A` 的前 **k** 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 `A` 的排序。

返回能使 `A` 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 `10 * A.length` 范围内的有效答案都将被判断为正确。 

**示例 1：**

```
输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 A = [3, 2, 4, 1]
第一次翻转后 (k=4): A = [1, 4, 2, 3]
第二次翻转后 (k=2): A = [4, 1, 2, 3]
第三次翻转后 (k=4): A = [3, 2, 1, 4]
第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 
```

**示例 2：**

```
输入：[1,2,3]
输出：[]
解释：
输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如[3，3]，也将被接受。
```

 

**提示：**

1. `1 <= A.length <= 100`
2. `A[i]` 是 `[1, 2, ..., A.length]` 的排列



###思路

#### 方法一：从大到小排序

**思路**

我们可以将最大的元素（在位置 `i`，下标从 1 开始）进行煎饼翻转 `i` 操作将它移动到序列的最前面，然后再使用煎饼翻转 `A.length` 操作将它移动到序列的最后面。 此时，最大的元素已经移动到正确的位置上了，所以之后我们就不需要再使用 `k`值大于等于 `A.length` 的煎饼翻转操作了。

我们可以重复这个过程直到序列被排好序为止。 每一步，我们只需要花费两次煎饼翻转操作。

**算法**

我们从数组 A 中的最大值向最小值依次进行枚举，每一次将枚举的元素放到正确的位置上。

每一步，对于在位置 `i` 的（从大到小枚举的）元素，我们会使用思路中提到的**煎饼翻转组合操作**将它移动到正确的位置上。 值得注意的是，执行一次煎饼翻转操作 `f`，会将位置在 `i, i <= f` 的元素翻转到位置 `f+1 - i` 上。

### Solution

```c++
class Solution {
    public List<Integer> pancakeSort(int[] A) {
        List<Integer> ans = new ArrayList();
        int N = A.length;

        Integer[] B = new Integer[N];
        for (int i = 0; i < N; ++i)
            B[i] = i+1;
        Arrays.sort(B, (i, j) -> A[j-1] - A[i-1]);

        for (int i: B) {
            for (int f: ans)
                if (i <= f)
                    i = f+1 - i;
            ans.add(i);
            ans.add(N--);
        }

        return ans;
    }
}
```

