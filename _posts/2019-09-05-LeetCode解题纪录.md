---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-09-05              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P108 将有序数组转换为二叉搜索树

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。


实例：

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

### 思路

* 二分法递归

### Solution

```c++
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        if(nums.empty()) return nullptr;
        return helper(nums,0,nums.size()-1);
    }

    TreeNode* helper(vector<int>& nums, int left, int right){
        if(left > right)
            return nullptr;
        int mid = (left+ right) /2;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = helper(nums, left,mid -1);
        root->right = helper(nums,mid+1, right);
        return root;
    }
};
```

## P965 单值二叉树

如果二叉树每个节点都具有相同的值，那么该二叉树就是*单值*二叉树。

只有给定的树是单值二叉树时，才返回 `true`；否则返回 `false`。

示例:

```
输入：[1,1,1,1,1,null,1]
输出：true

输入：[2,2,2,5,2]
输出：false
```

### 思路

* 递归

### Solution

```
class Solution
{
public:
    bool isUnivalTree(TreeNode *root)
    {
        if (!root || (!root->left && !root->right)) //如果当前结点为空或者结点的左右子树都为空（没有人可以与其比较），则为true
        {
            return true;
        }
        if (!root->left && root->right) //如果节点的左子树为空，右子树不为空，则先判断其与右子树根节点的值是否相等，再递归判断右子树
        {
            return (root->val == root->right->val) && isUnivalTree(root->right);
        }
        else if (root->left && !root->right) //同理，如果节点的右子树为空，左子树不为空，则先判断其与左子树根节点的值是否相等，再递归判断左子树
        {
            return (root->val == root->left->val) && isUnivalTree(root->left);
        }
        if (root->val == root->left->val && root->val == root->right->val) //如果该节点左子树右子树都不为空且三者值相等，则递归判断其左右子树
        {
            return isUnivalTree(root->left) && isUnivalTree(root->right);
        }
        return false; //不符合以上情况的则返回false
    }
};
```

