---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-01-31              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## 1.31 查找和替换模式

- 你有一个单词列表 `words` 和一个模式  `pattern`，你想知道 `words` 中的哪些单词与模式匹配。

  如果存在字母的排列 `p` ，使得将模式中的每个字母 `x` 替换为 `p(x)` 之后，我们就得到了所需的单词，那么单词与模式是匹配的。

  *（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）*

  返回 `words` 中与给定模式匹配的单词列表。

  你可以按任何顺序返回答案。

   

  **示例：**

  ```
  输入：words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb"
  输出：["mee","aqq"]
  解释：
  "mee" 与模式匹配，因为存在排列 {a -> m, b -> e, ...}。
  "ccc" 与模式不匹配，因为 {a -> c, b -> c, ...} 不是排列。
  因为 a 和 b 映射到同一个字母。
  ```

   

  **提示：**

  - `1 <= words.length <= 50`
  - `1 <= pattern.length = words[i].length <= 20`



### 思路

构造一个hashmap，遍历每一个字符串，将该字符串中的每一个字符都和pattern中的每一个字符进行一一对应，例如，第一个"abc"，则遍历之后，a对应pattern中的a；第二个"b"遍历后对应pattern中的第二个"b"；但是第三个"c"和pattern中的"b"不对应，所以该字符不能压入list中。所以hashmap以pattern中的每个字符为key，以字符串中的每个字符为value，进行遍历。但是这里需要特别注意的地方是凡是pattern中不一样的字符，所对应的字符串中的每一个字符必须不一样，哪怕对应到字符串中的字符没有在hashmap中出现过，这需要单独判断！！！

### Solution

```c++
class Solution {
        /**
     * 查找和替换模式
     * @param words
     * @param pattern
     * @return
     */
    public List<String> findAndReplacePattern(String[] words, String pattern) {
        List<String> result = new ArrayList<>();
        char[] patternChars = pattern.toCharArray();
        for (String word : words) {
            char[] wordChars = word.toCharArray();
            //是否匹配
            boolean match = true;
            //用于存储映射关系的Map
            Map<Character, Character> map = new HashMap<>();
            for (int i = 0; i < patternChars.length; i++) {
                char p = patternChars[i];
                char w = wordChars[i];
                if (map.containsKey(p)) {//模式中的字母是否已经映射已经被映射
                    char value = map.get(p);
                    if (value != w) {
                        match = false;
                        break;
                    }
                } else {
                    if(map.containsValue(w)){//判断单词中的字母是否被映射，防止模式多个字母都映射单词中的同一个字母
                        match = false;
                        break;
                    }else {
                        map.put(p, w);
                    }
                }
            }
            if (match) {
                result.add(word);
            }
        }
        return result;
    }
}
```



## 1.21 顶端迭代器

给定一个迭代器类的接口，接口包含两个方法： `next()` 和 `hasNext()`。设计并实现一个支持 `peek()` 操作的顶端迭代器 -- 其本质就是把原本应由 `next()` 方法返回的元素 `peek()` 出来。

**示例:**

```
假设迭代器被初始化为列表 [1,2,3]。

调用 next() 返回 1，得到列表中的第一个元素。
现在调用 peek() 返回 2，下一个元素。在此之后调用 next() 仍然返回 2。
最后一次调用 next() 返回 3，末尾元素。在此之后调用 hasNext() 应该返回 false。
```



### Solution

```c++
// Java Iterator interface reference:
// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html
class PeekingIterator implements Iterator<Integer> {
    
    private Iterator<Integer> mIterator;
    private Integer next;

    public PeekingIterator(Iterator<Integer> iterator) {
        // initialize any member here.
        this.mIterator = iterator;
    }

    // Returns the next element in the iteration without advancing the iterator.
    public Integer peek() {
        if (next == null && mIterator.hasNext()) {
            next = mIterator.next();
        }
        return next;
    }

    // hasNext() and next() should behave the same as in the Iterator interface.
    // Override them if needed.
    @Override
    public Integer next() {
        if (next == null) {
            return mIterator.next();
        } else {
            Integer temp = next;
            next = null;
            return temp;
        }
    }

    @Override
    public boolean hasNext() {
        return next != null || mIterator.hasNext();
    }
}
```

