---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-16              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1026 统计单词个数

题目描述：

给出一个长度不超过200的由小写英文字母组成的字母串(约定;该字串以每行20个字母的方式输入，且保证每行一定为20个)。要求将此字母串分成k份(1<k≤40)，且每份中包含的单词个数加起来总数最大(每份中包含的单词可以部分重叠。当选用一个单词之后，其第一个字母不能再用。例如字符串this中可包含this和is，选用this之后就不能包含th)。

单词在给出的一个不超过6个单词的字典中。

要求输出最大的个数。

输入格式：

每组的第一行有2个正整数(p,k)

p表示字串的行数,k表示分为k个部分。

接下来的p行，每行均有20个字符。

再接下来有1个正整数s，表示字典中单词个数。(1≤s≤6)

接下来的s行，每行均有1个单词。

输出格式：

1个整数，分别对应每组测试数据的相应结果。

示例:

```
1 3
thisisabookyouareaoh
4
is
a
ok
sab

7（this/isabookyoua/reaoh）
```

### 思路

* 实质问题就是分组的时候，切不同的点会造成不一样的结果，选取最优的切点
* 一开始，不分开和一定是最大的，你只要依次遍历每个点，看能否找到符合的单词，找到一个就行了，因为找到一个单词只影响第一个字母。从i和i+1之间分开意味着原来可能连成单词的被拆开，所以只需要找到每次分开使得失去单词数最小的切开点就行了。
* 用d[i]表示拆分成i个，能得到最大的和 用t[i]表示i到i+1中间是否已被切过 0表示没有，1表示已经被切开过
* 首先很明显d[1] = 整个字符串包含的所有单词和
* 然后从2-k贪心，对每个点遍历找出从这个点切开，导致单词强行分开的点的数目最少的 即 d[i] = d[i-1]+minum(此为最佳切点，失去的单词数目最少)
* 最后d[k]就是答案


### Solution

```java
#include<stdio.h>
#define min(a,b) ((a)<(b)?(a):(b))
#define LEN 20
char c[201] = {0}, word[6][200] = {0};
int d[41] = {0}, t[41] = {0};
int main()
{
    int p, k, s, i, j, m, n, f, g, minum;
    scanf("%d%d", &p, &k);
    for(i = 0; i < p; i++)
        scanf("%s", c+i*LEN+1);
    scanf("%d", &s);
    for(i = 0; i < s; i++)
        scanf("%s", word[i]);
    for(i = 1; i <= p*LEN; i++)
        for(j = 0; j < s; j++)
        {
            for(m = 0; word[j][m] != 0; m++)
                if(word[j][m] != c[i+m])
                    break;
            if(word[j][m] == 0)
            {
                d[1]++;
                break;
            }
        }
    for(i = 2; i <= k; i++)
    {
        minum = 99999;
        for(j = 1; j <= p*LEN-1; j++)
            if(!t[j])
            {
                f = 0;
                for(m = 0; m < s; m++)
                    for(n = 0; word[m][n+1] != 0; n++)
                        if(word[m][n] == c[j] && word[m][n+1] == c[j+1])
                        {
                            f++;
                            break;
                        }
                if(minum > f)
                {
                    minum = f;
                    g = j;
                }
            }
        d[i] = d[i-1]-minum;
        t[g] = 1;
    }
    printf("%d\n", d[k]);
    return 0;
}
```


