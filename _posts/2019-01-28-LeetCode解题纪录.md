---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-01-28              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## 1.28 所有可能的满二叉树

- *满二叉树*是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。

  返回包含 `N` 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。

  答案中每个树的每个`结点`都**必须**有 `node.val=0`。

  你可以按任何顺序返回树的最终列表。



### 思路

#### 方法：递归

**思路与算法**

令 FBT(N) 作为所有含 N 个结点的可能的满二叉树的列表。

每个满二叉树 T 含有 3 个或更多结点，在其根结点处有 2 个子结点。这些子结点 `left` 和 `right` 本身就是满二叉树。

因此，对于 N≥3，我们可以设定如下的递归策略：FBT(N)= [对于所有的 x，所有的树的左子结点来自 FBT(x)而右子结点来自 FBT(N−1−x)]。

此外，通过简单的计数参数，没有满二叉树具有正偶数个结点。

最后，我们应该缓存函数 FBT之前的结果，这样我们就不必在递归中重新计算它们。

### Solution

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> allPossibleFBT(int N) {
        vector<vector<TreeNode*>> dp(N+1);
        dp[1].push_back({new TreeNode(0)});

        for(int i = 3; i <= N; i+=2)
            for(int l = 1; l <= i - 2; l+=2){
                int r = i - 1 - l;

                for(auto& ltree: dp[l]){
                    for(auto& rtree: dp[r]){
                        TreeNode* root = new TreeNode(0);
                        root->left = ltree;
                        root->right = rtree;
                        dp[i].push_back(root);
                    }

                }
            }
        return dp[N];
    }
};
```



## 1.28 组合

给定两个整数 *n* 和 *k*，返回 1 ... *n* 中所有可能的 *k* 个数的组合。

**示例:**

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

### 思路

这道题让求1到n共n个数字里k个数的组合数的所有情况，还是要用深度优先搜索DFS来解，根据以往的经验，像这种要求出所有结果的集合，一般都是用DFS调用递归来解。那么我们建立一个保存最终结果的大集合res，还要定义一个保存每一个组合的小集合out，每次放一个数到out里，如果out里数个数到了k个，则把out保存到最终结果中，否则在下一层中继续调用递归。

### Solution

```c++
class Solution {
public:
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> res;
        vector<int> out;
        helper(n, k, 1, out, res);
        return res;
    }
    void helper(int n, int k, int level, vector<int>& out, vector<vector<int>>& res) {
        if (out.size() == k) {res.push_back(out); return;}
        for (int i = level; i <= n; ++i) {
            out.push_back(i);
            helper(n, k, i + 1, out, res);
            out.pop_back();
        }
    }
};
```

