---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-27              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1037 产生数

题目描述：

给出一个整数n 和k 个规则。

求出：

经过任意次的变换（0次或多次），能产生出多少个不同整数。

仅要求输出个数。

输入格式：
$$
\begin{array}{l}{n, k(1 \leq n \leq 20, k<n)} \\ {x_{1}, x_{2}, \ldots, x_{n}\left(1 \leq x_{i} \leq 5000000\right)}\end{array}
$$
输出格式：

1个整数（满足条件的个数）

实例：

```
234 2
2 5
3 6

4
```

### 思路

* ans=每个位上可以取的数字的种数

  所以我们要做的就是统计每种数字可以变换成哪些数字

  同时注意统计自己（因为可以不变）

  然而两次都忽略了当x --- > y后，就可以进行y的变换了，

  所以由于这个特性，单纯统计就不好计算了，

  所以我们采用深搜，并且判断走过的不能走，以免陷入死循环，

  同时由于ans会很大，所以要用高精


### Solution

```c++
#include <iostream>
#include <string>
using namespace std;
string str;
int k,vis[10][10],f[10],num[101];
inline void floyd() {  //弗洛伊德
  for (int k = 0;k <= 9;k++)
    for (int i = 0;i <= 9;i++)
      for (int j = 0;j <= 9;j++) vis[i][j] = vis[i][j] || (vis[i][k] && vis[k][j]);
}
int main (){
  ios::sync_with_stdio(false);
  cin >> str >> k;
  while (k--) {
    int a,b;
    cin >> a >> b;
    vis[a][b] = true;  //a可以变成b
  }
  for (int i = 0;i <= 9;i++) vis[i][i] = true;  //自己可以变成自己
  floyd();
  for (int i = 0;i <= 9;i++)
    for (int j = 0;j <= 9;j++)
      if (vis[i][j]) f[i]++;  //求出i可以变成多少种数字
  int len = 2; num[1] = 1;
  for (int i = 0;i < (int)str.length();i++) {  //高精度
    for (int j = 1;j <= 100;j++) num[j] *= f[str[i]-'0'];
    for (int j = 1;j <= 100;j++)
      if (num[j] >= 10) {  //进位
        num[j+1] += num[j]/10;
        num[j] %= 10;
      }
    while (num[len]) len++;  //求出长度
  }
  for (int i = len-1;i >= 1;i--) cout << num[i];  //输出
  return 0;
}
```



