---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-24              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1034 矩形覆盖

题目描述：

在平面上有n个点(n≤50)，每个点用一对整数坐标表示。例如：当n=4 时，4个点的坐标分另为：p1(1,1)，p2(2,2)，p3(3,6)，P4(0,7)，见图一。

这些点可以用k个矩形(1≤k≤4)全部覆盖，矩形的边平行于坐标轴。当 k=2 时，可用如图二的两个矩形s1,s2 覆盖，s1,s2 面积和为4。问题是当n个点坐标和k给出后，怎样才能使得覆盖所有点的k个矩形的面积之和为最小呢？

约定：覆盖一个点的矩形面积为0；覆盖平行于坐标轴直线上点的矩形面积也为0。各个矩形必须完全分开（边线与顶点也都不能重合）。

输入格式：

$$
\begin{array}{l}{n k} \\ {x_{1} y_{1}} \\ {x_{2} y_{2}} \\ {\ldots \ldots} \\ {x_{n} y_{n}\left(0 \leq x_{i}, y_{i} \leq 500\right)}\end{array}
$$
输出格式：

输出至屏幕。格式为：

1个整数，即满足条件的最小的矩形面积之和。

实例：

```
4 2
1 1
2 2
3 6
0 7

4
```

### 思路

* 暴力搜索
* 暴力枚举每个点被哪个矩形覆盖


### Solution

```c++
#include<bits/stdc++.h>
using namespace std;

int getint(){
    int x=0,f=1; char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}
    return f*x;
}
const int MAXN=100;
const int inf=0x3f3f3f3f;
struct POINT{int X,Y;}point[MAXN];
struct REG{int x1,y1,x2,y2;}reg[10];
int n,k,ans=inf;
int insert(int p,int r){//矩形r从原来状态变到覆盖点p所增大的面积    
    if(reg[r].x1<0){
        reg[r].x1=reg[r].x2=point[p].X;
        reg[r].y1=reg[r].y2=point[p].Y;
        return 0;
    }
    int ls=(reg[r].x2-reg[r].x1)*(reg[r].y2-reg[r].y1);//原面积 
    /*以下是分类讨论*/
    if(point[p].X<reg[r].x1){
        reg[r].x1=point[p].X;
        if(point[p].Y<reg[r].y1) reg[r].y1=point[p].Y;
        if(reg[r].y2<point[p].Y) reg[r].y2=point[p].Y;
        return (reg[r].x2-reg[r].x1)*(reg[r].y2-reg[r].y1)-ls;
    }
    if(reg[r].x1<=point[p].X&&point[p].X<=reg[r].x2){
        if(point[p].Y>reg[r].y2){
            reg[r].y2=point[p].Y;
            return (reg[r].x2-reg[r].x1)*(reg[r].y2-reg[r].y1)-ls;
        }
        if(point[p].Y<reg[r].y1){
            reg[r].y1=point[p].Y;
            return (reg[r].x2-reg[r].x1)*(reg[r].y2-reg[r].y1)-ls;
        }
        return 0;
    }
    if(reg[r].x2<point[p].X){
        reg[r].x2=point[p].X;
        if(point[p].Y<reg[r].y1) reg[r].y1=point[p].Y;
        if(reg[r].y2<point[p].Y) reg[r].y2=point[p].Y;
        return (reg[r].x2-reg[r].x1)*(reg[r].y2-reg[r].y1)-ls;
    }
    /*以上是分类讨论*/
}
inline bool check(){//是否有矩形重叠 
    for(int i=1;i<=k;++i)
        for(int j=1;j<=k;++j){
            if(i==j||reg[i].x1<0||reg[j].x1<0) continue;
            if(reg[i].x1<=reg[j].x1&&reg[j].x1<=reg[i].x2&&
               reg[i].y1<=reg[j].y1&&reg[j].y1<=reg[i].y2) return true;
            if(reg[i].x1<=reg[j].x1&&reg[j].x1<=reg[i].x2&&
               reg[i].y1<=reg[j].y2&&reg[j].y2<=reg[i].y2) return true;
            if(reg[i].x1<=reg[j].x2&&reg[j].x2<=reg[i].x2&&
               reg[i].y1<=reg[j].y1&&reg[j].y1<=reg[i].y2) return true;
            if(reg[i].x1<=reg[j].x2&&reg[j].x2<=reg[i].x2&&
               reg[i].y1<=reg[j].y2&&reg[j].y2<=reg[i].y2) return true;
        }
    return false;
}
void dfs(int used,int sum){
    if(check()||sum>=ans) return;//check判断矩形是否有重叠，最优化剪枝 
    if(used>n){
        ans=min(ans,sum); return;
    }
    for(int i=1;i<=k;++i){//暴力枚举当前点(点 used )被哪个矩形(矩形 i )覆盖 
        int lx1=reg[i].x1,lx2=reg[i].x2,ly1=reg[i].y1,ly2=reg[i].y2;
        dfs(used+1,sum+insert(used,i));
        reg[i].x1=lx1,reg[i].x2=lx2,reg[i].y1=ly1,reg[i].y2=ly2;
    }
}
int main(){
    n=getint(),k=getint();
    for(int i=1;i<=n;++i) point[i].X=getint(),point[i].Y=getint();//read in
    for(int i=1;i<=k;++i) reg[i].x1=reg[i].x2=reg[i].y1=reg[i].y2=-1;//initialize
    dfs(1,0);
    cout<<ans<<endl;
}
```


