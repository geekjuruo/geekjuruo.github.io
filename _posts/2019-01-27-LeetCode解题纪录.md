---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-01-27              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## 1.27 下一个全排列

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**原地**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`

### 思路

我们需要找到给定数字列表的下一个字典排列，而不是由给定数组形成的数字。

*  方法一：暴力求解

  * 在这种方法中，我们找出由给定数组的元素形成的列表的每个可能的排列，并找出比给定的排列更大的排列。 但是这个方法是一种非常天真的方法，因为它要求我们找出所有可能的排列 这需要很长时间，实施起来也很复杂。 因此，这种方法根本无法通过。 所以，我们直接采用正确的方法。

* 方法二：一遍扫描

  * **算法**

    首先，我们观察到对于任何给定序列的降序，没有可能的下一个更大的排列。

    例如，以下数组不可能有下一个排列：

    ```
    [9, 5, 4, 3, 1]
    ```

    我们需要从右边找到第一对两个连续的数字 a[i] 和 a[i−1]，它们满足 a[i]>a[i−1]。现在，没有对 a[i−1]右侧的重新排列可以创建更大的排列，因为该子数组由数字按降序组成。因此，我们需要重新排列 a[i−1] 右边的数字，包括它自己。

    现在，什么样的重新排列将产生下一个更大的数字？我们想要创建比当前更大的排列。因此，我们需要将数字 a[i−1]替换为位于其右侧区域的数字中比它更大的数字，例如 a[j]a[j]。

    我们交换数字 a[i−1] 和 a[j]。我们现在在索引 i−1处有正确的数字。 但目前的排列仍然不是我们正在寻找的排列。我们需要通过仅使用 a[i−1]右边的数字来形成最小的排列。 因此，我们需要放置那些按升序排列的数字，以获得最小的排列。

    但是，请记住，在从右侧扫描数字时，我们只是继续递减索引直到我们找到 a[i]和 a[i−1]这对数。其中，a[i]>a[i−1]。因此，a[i−1]右边的所有数字都已按降序排序。此外，交换 a[i−1]和 a[j] 并未改变该顺序。因此，我们只需要反转 a[i−1]之后的数字，以获得下一个最小的字典排列。

### Solution

```c++
public class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## 1.27 无重复的全排列

给定一个**没有重复**数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

### 思路

这是很经典的全排列问题，本题的解法很多。因为这里的所有数都是相异的，故笔者采用了交换元素+DFS的方法来求解。 **交换法**的思路是for(i = start to end)，循环中: swap (第start个和第i个)，递归调用(start+1)，swap back

### Solution

```c++
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        if(num.size() == 0) return res;
        permuteCore(num, 0);
        return res;
    }
private:
    vector<vector<int> > res;
    void permuteCore(vector<int> &num, int start){
        if(start == num.size()){
            vector<int> v;
            for(vector<int>::iterator i = num.begin(); i < num.end(); ++i){
                v.push_back(*i);
            }
            res.push_back(v);
        }
        for(int i = start; i < num.size(); ++i){
            swap(num, start, i);
            permuteCore(num, start+1);
            swap(num, start, i);
        }
    }
    void swap(vector<int> &num, int left, int right){
        int tmp = num[left];
        num[left] = num[right];
        num[right] = tmp;
    }
};
```



## 1.27 有重复的全排列

给定一个可包含重复数字的序列，返回所有不重复的全排列。

**示例:**

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

### 思路

本题与上一题略有不同，给定的序列中含有重复元素，需要返回这些数所能排列出的所有不同的序列集合。这里我们先考虑一下，它与第二题唯一的不同在于：在DFS函数中，做循环遍历时，如果与当前元素相同的一个元素已经被取用过，则要跳过所有值相同的元素。 举个例子：对于序列<1,1,2,3>。在DFS首遍历时，1 作为首元素被加到list中，并进行后续元素的添加；那么，当DFS跑完第一个分支，遍历到1 (第二个)时，这个1 不再作为首元素添加到list中，因为1 作为首元素的情况已经在第一个分支中考虑过了。为了实现这一剪枝思路，有了如下的解题算法。
1. 先对给定的序列nums进行排序，使得大小相同的元素排在一起。 

  2. 新建一个used数组，大小与nums相同，用来标记在本次DFS读取中，位置i的元素是否已经被添加到list中了。 

  3. 根据思路可知，我们选择跳过一个数，当且仅当这个数与前一个数相等，并且前一个数未被添加到list中。 
      根据以上算法，对题二的代码略做修改，可以得到如下的AC代码。 

      **(在处理一般性问题时，建议用此算法，毕竟题二只是特殊情况)**

### 本题目还可以借用第一题中的下一个排列的接口来实现，避免了递归，更加简单。

### Solution

```C++
class Solution {
public:
    vector<vector<int> > permuteUnique(vector<int> &num) {
        if(num.size() <= 0) return res;
        sort(num.begin(), num.end());
        res.push_back(num);
        int i = 0, j = 0;
        while(1){
            //Calculate next permutation
            for(i = num.size()-2; i >= 0 && num[i] >= num[i+1]; --i);
            if(i < 0) break;
            for(j = num.size()-1; j > i && num[j] <= num[i]; --j);
            swap(num, i, j);
            j = num.size()-1;
            ++i;
            while(i < j)
                swap(num, i++, j--);
            //push next permutation
            res.push_back(num);
        }
        return res;
    }
private:
    vector<vector<int> > res;
    void swap(vector<int> &num, int left, int right){
        int tmp = num[left];
        num[left] = num[right];
        num[right] = tmp;
    }
};
```

## 1.27 取特定位置的全排列字符串(第k个排列)

给出集合 `[1,2,3,…,*n*]`，其所有元素共有 *n*! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 *n* = 3 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 *n* 和 *k*，返回第 *k* 个排列。

**说明：**

- 给定 *n* 的范围是 [1, 9]。
- 给定 *k* 的范围是[1,  *n*!]。

**示例 1:**

```
输入: n = 3, k = 3
输出: "213"
```

**示例 2:**

```
输入: n = 4, k = 9
输出: "2314"
```

### Solution

> 连续k次调用第一个题目中的接口速度太慢

```c++
class Solution { 
    
    public String getPermutation(int n, int k) {
        /**
        直接用回溯法做的话需要在回溯到第k个排列时终止就不会超时了, 但是效率依旧感人
        可以用数学的方法来解, 因为数字都是从1开始的连续自然数, 排列出现的次序可以推
        算出来, 对于n=4, k=15 找到k=15排列的过程:
        
        1 + 对2,3,4的全排列 (3!个)         
        2 + 对1,3,4的全排列 (3!个)         3, 1 + 对2,4的全排列(2!个)
        3 + 对1,2,4的全排列 (3!个)-------> 3, 2 + 对1,4的全排列(2!个)-------> 3, 2, 1 + 对4的全排列(1!个)-------> 3214
        4 + 对1,2,3的全排列 (3!个)         3, 4 + 对1,2的全排列(2!个)         3, 2, 4 + 对1的全排列(1!个)
        
        确定第一位:
            k = 14(从0开始计数)
            index = k / (n-1)! = 2, 说明第15个数的第一位是3 
            更新k
            k = k - index*(n-1)! = 2
        确定第二位:
            k = 2
            index = k / (n-2)! = 1, 说明第15个数的第二位是2
            更新k
            k = k - index*(n-2)! = 0
        确定第三位:
            k = 0
            index = k / (n-3)! = 0, 说明第15个数的第三位是1
            更新k
            k = k - index*(n-3)! = 0
        确定第四位:
            k = 0
            index = k / (n-4)! = 0, 说明第15个数的第四位是4
        最终确定n=4时第15个数为3214 
        **/
        
        StringBuilder sb = new StringBuilder();
        // 候选数字
        List<Integer> candidates = new ArrayList<>();
        // 分母的阶乘数
        int[] factorials = new int[n+1];
        factorials[0] = 1;
        int fact = 1;
        for(int i = 1; i <= n; ++i) {
            candidates.add(i);
            fact *= i;
            factorials[i] = fact;
        }
        k -= 1;
        for(int i = n-1; i >= 0; --i) {
            // 计算候选数字的index
            int index = k / factorials[i];
            sb.append(candidates.remove(index));
            k -= index*factorials[i];
        }
        return sb.toString();
    }
}
```

