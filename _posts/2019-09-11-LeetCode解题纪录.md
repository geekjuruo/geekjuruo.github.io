---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-09-11              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1002 查找常用字符

给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。

你可以按任意顺序返回答案。


实例：

```
输入：["bella","label","roller"]
输出：["e","l","l"]

输入：["cool","lock","cook"]
输出：["c","o"]
```

### 思路

* 用第一个单词的字母，遍历其他的单词即可

### Solution

```c++
class Solution {
public:
	vector<string> commonChars(vector<string>& A) {
		vector<string> ans;
		int num = A.size();
		int count[26];
        
        string use[26] = { "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z" };
		
		for (int i = 0; i < 26; i++)
			count[i] = 101;
		for (int i = 0; i < num; i++) {
			int word[26] = { 0 };
			int len = A[i].length();
			for (int j = 0; j < len; j++)
				word[(int)A[i][j] - 97]++;
			for (int j = 0; j < 26; j++)
				if (count[j]) {
					count[j] = count[j] < word[j] ? count[j] : word[j];
				}
		}
		for (int i = 0; i < 26; i++) {
			if (count[i]) {
				for (int j = 0; j < count[i]; j++) {
					string s(1, (char)(i + 97));
					ans.push_back(s);
				}
			}
		}
		return ans;
	}
};
```

## P762 二进制表示中质数个计算置位

给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。

（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）

示例:

```
输入: L = 6, R = 10
输出: 4
解释:
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)

输入: L = 10, R = 15
输出: 5
解释:
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
```

### 思路

* 思路简单

### Solution

```c++
class Solution {
public:
    int countPrimeSetBits(int L, int R) {
        int ans=0;
        for(int i=L;i<=R;i++)
        {
            int tmpNum=i,tmpCnt=0;
            while(tmpNum!=0)
            {
                tmpNum&=tmpNum-1;
                tmpCnt++;
            }
            if(isPrime(tmpCnt)) ans++;
        }
        return ans;
    }
    bool isPrime(int num)
    {
        if(num<2) return false;
        for(int i=2;i*i<=num;i++)
        {
            if(num%i==0) return false;
        }
        return true;
    }
};
```

