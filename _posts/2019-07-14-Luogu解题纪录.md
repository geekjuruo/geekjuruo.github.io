---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-07-14              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1002 过河卒

棋盘上A点有一个过河卒，需要走到目标B点。卒行走的规则：可以向下、或者向右。同时在棋盘上C点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。棋盘用坐标表示，A点(0,0)、B点(n,m)(n, m为不超过20的整数)，同样马的位置坐标是需要给出的。

现在要求你计算出卒从A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

**示例:**

```
输入: 6 6 3 3
输出:6
```

### 思路

动态规划，得出状态转移方程即可。

#### $f[i][j]=max(f[i−1][j]+f[i][j−1],f[i][j])$

### Solution

```java
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define ull unsigned long long
using namespace std;
inline int read(){//快速读入
    char c=getchar();int num=0;bool b=0;
    for(;c<'0'||c>'9';b=(c=='-'?1:0),c=getchar());
    for(;c>='0'&&c<='9';num=(num<<3)+(num<<1)+(c^'0'),c=getchar());
    return b?-num:num;
}
const int fx[]={0,-2,-1,1,2,2,1,-1,-2};
const int fy[]={0,1,2,2,1,-1,-2,-2,-1};
//马可以走到的位置
int bx,by,mx,my;
ull ans;
ull f[30][30];//f[i][j]代表从A点到(i,j)会经过的线路数
bool s[30][30];//判断这个点有没有马盯着
int main(){
    bx = read();
    by = read();
    mx = read();
    my = read();
    ++bx; ++by; ++mx; ++my;
    //坐标+1以防越界
    f[1][1]=1;//初始化
    s[mx][my]=1;//标记马的位置
    for(int i=1;i<=8;i++)
        s[ mx + fx[i] ][ my + fy[i] ]=1;
    for(int i=1;i<=bx;i++){
        for(int j=1;j<=by;j++){
            if(s[i][j])continue;
            f[i][j]=max( f[i][j] , f[i-1][j] + f[i][j-1] );
            //状态转移方程
        }
    }
    printf("%llu\n",f[bx][by]);
    return 0;
}
```


