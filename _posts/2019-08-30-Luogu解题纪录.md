---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-30              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1040 加分二叉树

题目描述：

设一个n个节点的二叉树tree的中序遍历为（1,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di,tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：

subtree的左子树的加分×subtree的右子树的加分＋subtree的根的分数。

若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出；

（1）tree的最高加分

（2）tree的前序遍历

输入格式：

第1行：

1个整数n(n<30)，为节点个数。

第2行：

n个用空格隔开的整数，为每个节点的分数（分数<100）。

输出格式：

第1行：

1个整数，为最高加分（Ans ≤4,000,000,000）。

第2行：n个用空格隔开的整数，为该树的前序遍历。

输入输出样例：

```
5
5 7 1 2 10

145
3 1 2 4 5
```

### 思路

* 前序遍历：先访问根再访问左子树再访问右子树，简称：根左右（性质：遍历出的序列的第一个节点是整个tree的根）
* 中序遍历：左根右（性质：遍历出的序列的中间某个节点是整个树的根）
* 后序遍历：左右根（性质：遍历出来的序列的末尾一定是整个tree的根）
* 其实就是让你在整个序列中选定一个根节点，求出此节点左子树的最大分数，与右子树的最大分数。说白了就是让你枚举子树的根。 既然知道了是枚举子树的根，那做法很显然了

### Solution

```c++
#include <bits/stdc++.h>//万能头文件 
#define ll long long 
//中序遍历具有的性质：在序列中必有且只有一个节点是根，使得此节点左边的序列是左子树的中序遍历，右边序列是右子树的中序遍历
using namespace std;
int n;
int score[32];//没记错的话score这个单词意思应该是分数，用它来表示每个节点的分数 
ll f[32][32];//用于保存一个区间内最大分数 
int root[32][32];//保存根，题目要求输出 
ll ans=0;
ll dfs(int l,int r){
    if(f[l][r]!=-1)return f[l][r];
    if(l>r||r<l){
        return 1; 
    }//注意好递归边界！！！ dfs到l>r或r<l,意味着子树为空，题目要求返回1 
    ll sum=0;
    for(int i=l;i<=r;i++){
        if(dfs(l,i-1)*dfs(i+1,r)+score[i]>sum){
            sum=dfs(l,i-1)*dfs(i+1,r)+score[i];//要求[l,r]最大分数，先求[l,i-1],与[i+1,r]的最大分数 
            root[l][r]=i;//记录根节点 
        }
    }
    f[l][r]=sum;
    return f[l][r];
}
void print(int l,int r){
    if(l>r||r<l)return ;//注意，空子树不需要输出，空格都不用 
    if(l==r){
        cout<<l<<" ";
        return ;
    }
    cout<<root[l][r]<<" ";
    print(l,root[l][r]-1);
    print(root[l][r]+1,r);
}//递归输出前序遍历 
int main(){
    memset(f,-1,sizeof(f));//初始化为-1，因为n可能为0 
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>score[i];
        f[i][i]=score[i];//区间[i,i]表示i是叶子节点，题目要求保留原来的分数 
    }
    cout<<dfs(1,n)<<endl;
    print(1,n);

}
```



