---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-01              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1011 车站

火车从始发站（称为第1站）开出，在始发站上车的人数为a，然后到达第2站，在第2站有人上、下车，但上、下车的人数相同，因此在第2站开出时（即在到达第3站之前）车上的人数保持为a人。从第3站起（包括第3站）上、下车的人数有一定规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第n−1站），都满足此规律。现给出的条件是：共有N个车站，始发站上车的人数为a，最后一站下车的人数是m（全部下车）。试问x站开出时车上的人数是多少？

输入格式：

a(≤20)，n(≤20)，m(≤2000)，和x(≤20)，

输出格式：

从x站开出时车上的人数。

示例:

```
5 7 32 4
13
```

### 思路

* 斐波那契数列

* 在做之前，我们先找找规律：

  1. 第一站：上车 a人；车上有 a 人；
  2. 第二站：假设上车 u 人，则下车 u 人；车上仍然是a人；
  3. 第三站：上车人数等于前两站上车人数之和：a+u 人，下车人数等于上次上车人数 u 人；净上车人数为 a 人；车上有 2a 人；
  4. 第四站：上车人数 =a+2u，下车人数 =a+u；净上车人数 =u；车上有多少人呢？就是 2a+u；
  5. 第五站：上车人数 =2a+3u，下车人数 =a+2u，净上车人数 =a+u；车上有 3a+2u人；
  6. 第六站：上车人数 =3a+5u，下车 2a+3u 人，净上车人数 =a+2u；车上有 4a+4u 人……

  这里不必在列下去了，发现规律了吗？

  将第三站净上车人数看作x1，第四站看作x2，第五站为x3，第六站为x4，有 x1+x2=x3, x2+x3=x4…x1+x2=x3, x2+x3=x4…**斐波那契数列**

* 对a和u的系数进行存储

### Solution

```java
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ull unsigned long long
using namespace std;
inline int read(){//快速读入
    char c=getchar();int num=0;bool b=0;
    for(;c<'0'||c>'9';b=(c=='-'?1:0),c=getchar());
    for(;c>='0'&&c<='9';num=(num<<3)+(num<<1)+(c^'0'),c=getchar());
    return b?-num:num;
}



int main(){
    int a = read();
    int n = read();
    int m = read();
    int x = read();

    int A[n+1];
    int U[n+1];

    int sum_A = 0;
    int sum_U = 0;

    int u = 0;
    A[1] = 0; U[1] = 0;
    A[2] = 0; U[2] = 0;
    A[3] = 1; U[3] = 0;
    A[4] = 0; U[4] = 1;

    if(n >= 5) {
        for (int i = 5; i <= n; i++) {
            A[i] = A[i-1] + A[i-2];
            U[i] = U[i-1] + U[i-2];
        }

        for (int i = 1; i <= n - 1; i++) {
            sum_A += A[i];
            sum_U += U[i];
        }


        u = (m  - sum_A*a - a)/sum_U;
    }


    sum_A = 0;
    sum_U = 0;
    for (int i = 1; i <= x ; i++) {
        sum_A += A[i];
        sum_U += U[i];
    }

    int result = a*sum_A + u*sum_U + a;

    cout<<result;
    return 0;
}
```


