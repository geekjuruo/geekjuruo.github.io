---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-07-23              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1004 方格取数

设有N×N的方格图(N≤9)，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字0。如下图所示（见样例）:

A
0  0  0  0  0  0  0  0
0  0 13  0  0  6  0  0
0  0  0  0  7  0  0  0
0  0  0 14  0  0  0  0
0 21  0  0  0  4  0  0
0  0 15  0  0  0  0  0
0 14  0  0  0  0  0  0
0  0  0  0  0  0  0  0
​				B

某人从图的左上角的A点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。此人从A点到B点共走两次，试找出2条这样的路径，使得取得的数之和为最大。

输入格式：

输入的第一行为一个整数N（表示N×N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。

输出格式：

只需输出一个整数，表示2条路径上取得的最大的和。

示例:

```
输入: 
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0
输出:
67

```

### 思路

这题，是四维动规的模板题。

我们考虑两个人同时走，就相当于数字三角形。

用fijkl表示第一个人走到(i,j)，第二个人走到(k,l)的最优解

状态转移方程为：
$$
f[i][j][k][l]=\max (f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k], f[i][j-1]]+a[i][j]+a[k][l]
$$
不过要判断i=k&&j=l的情况。

### Solution

```java
#include<iostream>
    #include<cstdio>
    #include<algorithm>
    using namespace std;
    int f[12][12][12][12],a[12][12],n,x,y,z;
    int main() {
        cin>>n>>x>>y>>z;
        while(x!=0||y!=0||z!=0){
            a[x][y]=z;
            cin>>x>>y>>z;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                for(int k=1;k<=n;k++){
                    for(int l=1;l<=n;l++){
                        f[i][j][k][l]=max(max(f[i-1][j][k-1][l],f[i-1][j][k][l-1]),max(f[i][j-1][k-1][l],f[i][j-1][k][l-1]))+a[i][j]+a[k][l];
                        if(i==k&&l==j)f[i][j][k][l]-=a[i][j];
                    }
                }
            }
        }
        cout<<f[n][n][n][n];
        return 0;
}
```


