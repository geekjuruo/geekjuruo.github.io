---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-09-02              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P500 键盘行

给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。


实例：

```
输入: ["Hello", "Alaska", "Dad", "Peace"]
输出: ["Alaska", "Dad"]
```

### 思路

* 建立map映射即可
* flag = 1表示在第一行；
  flag = 2第二行；
  flag = 3第三行；
  flag在123之间改变，表明不在同一行，结束当前单词；
  vector\<string> findWords(vector\<string>& words) {
  set\<char> dic1 = {'Q','W','E','R','T','Y','U','I','O','P'};
  set\<char> dic2 = {'A','S','D','F','G','H','J','K','L'};
  set\<char> dic3 = {'Z','X','C','V','B','N','M'};

### Solution

```c++
class Solution {
public:
    vector<string> findWords(vector<string>& words) 
    {
        string q{"qwertyuiop"};
        string a{"asdfghjkl"};
        string z{"zxcvbnm"};
        vector<string> ans;    

        for(int i=0;i<words.size();i++)
        {
            int d=0,b=0,c=0;
            for(int j=0;j<words[i].size();j++)
            {
                if(q.find(tolower(words[i][j]))!=string::npos) b++;
                if(a.find(tolower(words[i][j]))!=string::npos) c++;
                if(z.find(tolower(words[i][j]))!=string::npos) d++;
            }
            if(b==words[i].size()||c==words[i].size()||d==words[i].size()) 
                ans.push_back(words[i]);
        }
        return ans;      
    }
};
```

## P557 反转字符串中的单词 III

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

示例:

```
输入: "Let's take LeetCode contest"
输出: "s'teL ekat edoCteeL tsetnoc" 
```

### 思路

* 思路很简单，按照空格切分，然后逆转每个单词
  但是有个值得注意的地方，直接使用原字符串的话，首末单词判定的时候会出现特殊情况
  比如，如果按照单词后的空格作为切分标志，最后一个单词是特殊情况，末尾没有空格
  如果按照单词前面的空格作为切分标志，首单词前没有空格
  所以，这里思路很简单，先给原字符串末尾加一个空格，这样就能够统一处理所有单词
  按照单词尾部的空格为标志，逆转所有单词
  完事儿之后还要记得把字符串末尾的空格删掉
  代码还能写得更简洁，把自增自减运算符放在运算里面，然后去掉大括号
  但是这样会导致可读性变差
  所以代码就这样了，简单易懂

### Solution

```
class Solution {
public:
    string reverseWords(string s) {
        int pos=0;
        int left=0,right=0;
        s.push_back(' ');
        int len=s.length();
        while(pos<len){
            if(s[pos]==' '){
                right=pos-1;
                while(left<right){
                    swap(s[left], s[right]);
                    ++left;
                    --right;
                }    
                left=pos+1;
            }
            ++pos;
        }
        s.erase(s.end()-1);
        return s;
    }
};
```

