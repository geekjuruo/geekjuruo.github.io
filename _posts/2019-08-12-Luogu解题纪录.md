---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-12              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1022 计算器的改良

题目描述：

NCL是一家专门从事计算器改良与升级的实验室，最近该实验室收到了某公司所委托的一个任务：需要在该公司某型号的计算器上加上解一元一次方程的功能。实验室将这个任务交给了一个刚进入的新手ZL先生。

为了很好的完成这个任务，ZL先生首先研究了一些一元一次方程的实例：
$$
\begin{array}{l}{4+3 x=8} \\ {6 a-5+1=2-2 a} \\ {-5+12 y=0}\end{array}
$$
ZL先生被主管告之，在计算器上键入的一个一元一次方程中，只包含整数、小写字母及+、-、=这三个数学符号（当然，符号“-”既可作减号，也可作负号）。方程中并没有括号，也没有除号，方程中的字母表示未知数。

你可假设对键入的方程的正确性的判断是由另一个程序员在做，或者说可认为键入的一元一次方程均为合法的，且有唯一实数解。

输入格式：

一个一元一次方程。

输出格式：

解方程的结果(精确至小数点后三位)。

示例:

```
 6a-5+1=2-2a
 a=0.750
```

### 思路

* 1.去分母：在方程两边都乘以各分母的最小公倍数；
* 2.去括号：先去小括号，再去中括号，最后去大括号； 
* 3.**移项**：把含有未知数的项都移到方程的一边，其他项都移到方程的另一边；
* 4.**合并同类项**：把方程化成ax=b(a≠0)的形式；
* 5.**系数化成1**：在方程两边都除以未知数的系数a，得到方程的解


### Solution

```java
#include<cstdio>
#include<cstring>
using namespace std;
double num=0,x=0;//num是数字之和，x为系数之和 
char c,p;//c被用作读入每一个字符，p用来储存未知数是啥 
int a[100],l=1,mid,pd;//a[]储存每一个出现的数,l记录数组长度,mid分开等号两边,pd为判断此数字是正是负 
int main()
{
    memset(a,0,sizeof(a));//数组清0，因为第一个有可能是又前置符号的数，这样不好解决判断问题，索性全为0，最后加起来也没啥影响 
    pd=1;//默认开头第一个数为正 
    while(c!='=')//读入等号左边 
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;//只要判断是-数，切换到下一个数,设置这个数为负数 
        if(c=='+')
            ++l,pd=1;//判断为正，切换下一个数，设置这个数为正数 
        if(c>='0'&&c<='9')//读入的是数字 
        {
            if(!a[l])//这个数字字符是数字中的第一个 
                a[l]=(c-'0')*pd;//赋值（记得乘上判断的数） 
            else
                a[l]=a[l]*10+(c-'0')*pd;//数字中已经有数了，为了加上这个数，向前移一位再塞进去 （记得乘上判断的数） 
        }
        if(c>='a'&&c<='z')//发现未知数！ 
        {
            p=c;
            if(a[l]!=0)
                x+=a[l],a[l]=0;//如果有前面的系数，则存入系数集合，把塞在数字数组中的系数去掉 
            else
                x+=pd;//判断特殊情况如-x/+x 
            --l; //减去这一位数 
        }
    }
    mid=l,++l,pd=1;//存储mid，数组位数进一位，pd=1与上面同理 
    while(c!='\n')//同上 
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;
        if(c=='+')
            ++l,pd=1;
        if(c>='0'&&c<='9')
        {
            if(!a[l])
                a[l]=(c-'0')*pd;
            else
                a[l]=a[l]*10+(c-'0')*pd;
        }
        if(c>='a'&&c<='z')//这里有点不一样，因为未知数要放在等号左边所以这里要减去系数 
        {
            p=c;
            if(a[l]!=0)
                x-=a[l],a[l]=0;
            else
                x-=pd; 
            --l; 
        }
    }
    for(int i=1;i<=l;++i)//叠加数字 
    {
        if(i<=mid)//在等号左边要减去 
            num-=a[i];
        else//在等号右边的要加上 
            num+=a[i]; 
    }
    if(!(num/x))//这里要加个特判断，因为会出现-0，虽然-0和0等效，但评测机并不吃这一套 
        printf("%c=0.000",p);
    else
        printf("%c=%.3lf",p,num/x);//输出 
    return 0; 
}
```


