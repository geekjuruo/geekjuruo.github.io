---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-11              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1021 邮票面值设计

题目描述：

给定一个信封，最多只允许粘贴N张邮票，计算在给定K（N+K≤15）种邮票的情况下（假定所有的邮票数量都足够），如何设计邮票的面值，能得到最大值MAX，使在1至MAX之间的每一个邮资值都能得到。

例如，N=3，K=2，如果面值分别为1分、4分，则在1分～6分之间的每一个邮资值都能得到（当然还有8分、9分和12分）；如果面值分别为1分、3分，则在1分～7分之间的每一个邮资值都能得到。可以验证当N=3，K=2时，7

分就是可以得到的连续的邮资最大值，所以MAX=7，面值分别为1分、3分。

输入格式：

2个整数，代表N，K。

输出格式：

2行。第一行若干个数字，表示选择的面值，从小到大排序。

第二行，输出“MAX=S”，S表示最大的面值。

示例:

```
3 2

1 3
MAX=7
```

### 思路

* 必须要有1（满足连续性要求）

* 取数，单调递增地取

* 确定上下界，上界是上一个数+1

  以n=3,k=3为例:第一个面值肯定为1，但是第二个面值只能是

  但是第二个面值只能是2，3，4，因为面值为1的最多贴3张

  贴满的最大值为3，要保证数字连续,那么第二个数字最大是4

  所以我们可以得到规律，如果邮票张数为n，种类为k,那么从小到大的顺序，邮票a[i]的下一种面值的取值范围必然是f[i]+1到f[i]*n+1

* 深搜+动态规划

  如果已知邮票的不同面值，可以用动态规划求出这些不同面值的邮票能组合出的最大连续数：

  设dp[i]表示已知面值的邮票组合出面值为i所需要的最小邮票数，我们把已知的q种不同的邮票面值存在num中，则有状态转移方程：dp[i]=min(dp[i-f[j]]+1)

  然后随着搜索不断枚举面值集合，同时更新最大值


### Solution

```java
 #include<cstdio>
 #include<cstring>
 #include<algorithm>
 using namespace std;
const int maxn=51;
const int INF=2147483647;
int n,k,f[maxn],b[maxn],ans,dp[maxn*100];
void dfs(int x)
{
    if(x==k+1)
    {
        memset(dp,0,sizeof(dp));
        int i=0;
        while(dp[i]<=n)
        {
            i++;
            dp[i]=INF;
            for(int j=1;j<=k&&i-f[j]>=0;j++)
            {
                dp[i]=min(dp[i],dp[i-f[j]]+1);
            }
        }
        if(i-1>ans)
        {
            for(int j=1;j<=k;j++)
            {
                b[j]=f[j];
                ans=i-1;
            }
        }
        return;
    }
    for(int i=f[x-1]+1;i<=f[x-1]*n+1;i++)
    {
        f[x]=i;
        dfs(x+1);
    }
}
int main() 
{
    scanf("%d%d",&n,&k);
    f[1]=1;
    dfs(2);
    for(int i=1;i<=k;i++)printf("%d ",b[i]);
    printf("\n");
    printf("MAX=%d\n",ans);
    return 0;
}
```


