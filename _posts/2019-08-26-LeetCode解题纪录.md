---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-26              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P226 翻转二叉树

翻转一棵二叉树。

实例：

```
 	 4
   /   \
  2     7
 / \   / \
1   3 6   9

     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

### 思路

* 递归翻转


### Solution

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        TreeNode* temp;
        if(root==NULL){return NULL;}
       	temp=root->left;
        root->left=root->right;
        root->right=temp;
        invertTree(root->left);
        invertTree(root->right);
        return  root; 
    }
};
```

## P1051 高度检查器

学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。

请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。

示例:

```
输入：[1,1,4,2,1,3]
输出：3
解释：
高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
```

### 思路

* 笨方法，拷贝一份数组，将原数组排序，与拷贝数组比较，有几个不一样的元素

### Solution

```
class Solution {
public:
	int heightChecker(vector<int>& heights) {
		int ans = 0;
		int len = heights.size();
		vector<int> copy(len);
		for (int i = 0; i < len; i++)
			copy[i] = heights[i];
		sort(heights.begin(), heights.end());
		for (int i = 0; i < len; i++) {
			if (heights[i] != copy[i])
				ans++;
		}
		return ans;
	}
};
```

