---
layout:     post                    # 使用的布局（不需要改）
title:      Luogu洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-05              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P1015 回文数

题目描述：

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数56，将56加65（即把56从右向左读），得到121是一个回文数。

又如：对于十进制数87：

STEP1：87+78=165

STEP2：165+561=726

STEP3：726+627=1353

STEP4：1353+3531=4884

在这里的一步是指进行了一次N进制的加法，上例最少用了4步得到回文数4884。

写一个程序，给定一个N(2≤N≤10,N=16)进制数M(100位之内)，求最少经过几步可以得到回文数。如果在30

步以内（包含30步）不可能得到回文数，则输出Impossible!

输入格式：

两行，分别是N，M

输出格式：

STEP=ans

示例:

```
无
```

### 思路

* 高精度加法 + 回文数
* 读入数字，并将这个数字的每一位存入 x 数组（反着存，即高位在后，低位在前，从低位到高位）。如果是**十六进制**（原来没有看到N=16导致百思不得其解），将ABCDEF分别转换成10,11,12,13,14,15再存入数组，这样方便接下来的高精度计算
* while循环。循环条件：不是回文数且步数不大于30，将这个数（x数组）的长度赋给变量 l，并将 x [ i ] 和 x [ l-i+1 ] 相加并将值赋给 sum [ i ] ，并加以进位判断等
* 判断回文（返回布尔值的函数find，返回true即为回文，返回false即为非回文）
* 

### Solution

```java
#include <bits/stdc++.h> 
using namespace std;
int n, q[1000001], l, w[1000001], ans;
string s;
void init() 
{
    int j = 0;
    for(int i = s.length() - 1; i >= 0 ; i--) 
    {
        if(s[i] >= '0' && s[i] <= '9') 
        {
            q[++j] = s[i] - '0';
        }
        else 
        {
            q[++j] = s[i] - 'A' + 10;
        } 
    }
}
void add(int a[], int b[]) 
{
    for(int i = 1; i <= l; i++)
    {
        a[i] += b[i];
        a[i + 1] += a[i] / n; 
        a[i] %= n;
    }
    if(a[l + 1] > 0) 
    {
        l++; 
    }
}
bool f(int a[]) 
{
    int ln = l;
    int i = 1;
    int j = l;
    while(ln--)
    {
        if(ln < l / 2) 
        {
            break;
        }
        if(a[i] != a[j])
        {
            return false; 
        }
        i++;
        j--;
    }
    return true;
}
void turn(int a[]) 
{
    int j = 0;
    for(int i = l; i >= 1; i--) 
    {
        w[++j] = a[i]; 
    }
}
int main()
{
    cin>>n>>s;
    init(); 
    l = s.length();
    while(!f(q)) 
    {
        turn(q);
        add(q, w); 
        ans++;
        if(ans > 30) 
        {
            break;
        }
    }
    if(ans > 30)
    {
        printf("Impossible!"); 
    }
    else
    {
        printf("STEP=%d", ans);
    }
    return 0;
}
```


