---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-09-09              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P206 反转链表

反转一个单链表。


实例：

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

### 思路

* 递归

### Solution

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head){
            return nullptr;
        }
        return reverse(head, head, head->next);        
    }
    
    ListNode* reverse(ListNode* head, ListNode* first, ListNode* target){
        if(!target){
            return head;
        }
        first->next = target->next;
        ListNode* temp = target->next;
        target->next = head;
        return reverse(target, first, temp);
    }
};
```

## P811 子域名访问计数

一个网站域名，如"discuss.leetcode.com"，包含了多个子域名。作为顶级域名，常用的有"com"，下一级则有"leetcode.com"，最低的一级为"discuss.leetcode.com"。当我们访问域名"discuss.leetcode.com"时，也同时访问了其父域名"leetcode.com"以及顶级域名 "com"。

给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如："9001 discuss.leetcode.com"。

接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。

示例:

```
示例 1:
输入: 
["9001 discuss.leetcode.com"]
输出: 
["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]
说明: 
例子中仅包含一个网站域名："discuss.leetcode.com"。按照前文假设，子域名"leetcode.com"和"com"都会被访问，所以它们都被访问了9001次。

示例 2
输入: 
["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
输出: 
["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]
说明: 
按照假设，会访问"google.mail.com" 900次，"yahoo.com" 50次，"intel.mail.com" 1次，"wiki.org" 5次。
而对于父域名，会访问"mail.com" 900+1 = 901次，"com" 900 + 50 + 1 = 951次，和 "org" 5 次。
```

### 思路

* 处理字符串

### Solution

```c++
class Solution {
public:
    vector<string> subdomainVisits(vector<string>& cpdomains) {
        map<string,int> domain;
        vector<string> output;    
        for(int i=0; i<cpdomains.size(); i++){
            size_t pos1 = cpdomains[i].find(" ");//找出空格的位置
            string temp = cpdomains[i].substr(0, pos1);//截取出表示访问次数的字符串
            int count = atoi(temp.c_str());//转为int
            if(pos1!=cpdomains[i].npos){
                string temp = cpdomains[i].substr(pos1+1,cpdomains[i].size()-1);//截取出最低一级的域名
                //output.push_back(temp);
                domain[temp] += count;//向map中插入最低一级的域名
                //cout << temp << endl;
            }  
            size_t pos2 = cpdomains[i].find(".");//找出"."的位置
            while(pos2!=cpdomains[i].npos){
                string temp = cpdomains[i].substr(pos2+1,cpdomains[i].size()-1);//依次截取高级域名
                domain[temp] += count;//向map中插入域名
                pos2 = cpdomains[i].find(".", pos2+1);//查找下一个"."
                //cout << temp << endl;
            }
        }
        map<string,int>::iterator it;
        for(it = domain.begin(); it!=domain.end(); it++){
            string temp = std::to_string(it->second) + " " + it->first;//注意将int转为string
            output.push_back(temp);
            //cout << it->first << ":" << it->second << endl;
        }
        //cout << domain.size() <<endl;
        return output;
    }
};
```

