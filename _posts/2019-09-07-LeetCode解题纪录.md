---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-09-07              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P999 车的可用捕获量

在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。

车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。


实例：

```

```

### 思路

* 东南西北移动

### Solution

```c++
class Solution {
public:
    int numRookCaptures(vector<vector<char>>& board) {
        //找出R的位置
        int x,y;
        for(int i=0;i<board.size();i++)
            for(int j=0;j<board[i].size();j++)
                if(board[i][j]=='R')
                {
                    x=i;y=j;
                }
        int sum=0;
        //向北遍历
        for(int i=x;i<8;i++)
        {
            if(board[i][y]=='B')break;
            if(board[i][y]=='p'){
                sum++;break;
            }
        }
        //向南遍历
        for(int i=x;i>=0;i--)
        {
            if(board[i][y]=='B')break;
            if(board[i][y]=='p'){
                sum++;break;
            }
        }
        //向东遍历
        for(int j=y;j<8;j++)
        {
           if(board[x][j]=='B')break;
            if(board[x][j]=='p')
            {
                sum++;break;
            }
        }
        //向西遍历
        for(int j=y;j>=0;j--)
        {
           if(board[x][j]=='B')break;
            if(board[x][j]=='p')
            {
                sum++;break;
            }
        }
         return sum;   
    }
};
```

## P922 按奇偶排序数组 II

给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

示例:

```
输入：[4,2,5,7]
输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
```

### 思路

* 首尾双指针

### Solution

```c++
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& A) {
        int pre1=1,pre2=0,aLen=A.size();
        while( true ) {
            while(  pre2<aLen &&  !(A[pre2] & 1) ) pre2+=2;//找到 不是偶数但又是偶数索引
            while(  pre1<aLen && A[pre1] & 1  ) pre1+=2;//找到 不是奇数但 是奇数索引
            if( pre1 < aLen || pre2<aLen )
                swap(A[pre1],A[pre2]);
            else
                break;
        }
        return A;
    }
};
```

