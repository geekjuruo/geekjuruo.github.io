---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-01-21              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法
---

## 1.21 有效的数独

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。



### 思路

一次迭代：

- 如何枚举子数独？

> 可以使用 `box_index = (row / 3) * 3 + columns / 3`，其中 `/` 是整数除法。

- 如何确保行 / 列 / 子数独中没有重复项？

> 可以利用 `value -> count` 哈希映射来跟踪所有已经遇到的值。



### Solution

```c++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        bool flag = true;
        int row[9][10];//第一维为行序号
        int column[9][10];//第一维为列序号
        int sub[9][10]; //第一维为子块序号，定义为“(行/3)*3+列/3”
        for (int i = 0 ; i < 9; i++) {
            for(int j = 0 ; j < 10; j++) {
                row[i][j] = 0;
                column[i][j] = 0;
                sub[i][j] = 0;
            }
        }
    
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                
                if(board[i][j] != '.') {
                    int true_num = board[i][j] - '0';
                    row[i][true_num]++;
                    column[j][true_num]++;
                    sub[(i/3)*3 + j/3][true_num]++;
                }
            }
        }

        for(int i = 0; i < 9 ; i++) {
            for(int j = 0; j < 10 ; j++) {
                if(row[i][j] >= 2 || column[i][j] >= 2 || sub[i][j] >= 2) {
                    flag =  false;
                }
            }
        }
        return flag;
    }
};
```



## 1.21 报数

报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：

```
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

`1` 被读作  `"one 1"`  (`"一个一"`) , 即 `11`。
`11` 被读作 `"two 1s"` (`"两个一"`）, 即 `21`。
`21` 被读作 `"one 2"`,  "`one 1"` （`"一个二"` ,  `"一个一"`) , 即 `1211`。

给定一个正整数 *n*（1 ≤ *n* ≤ 30），输出报数序列的第 *n* 项。

注意：整数顺序将表示为一个字符串。



### Solution

```c++
class Solution {
public:
    string countAndSay(int n) {
        string a="1",temp="";
        for(int i=1;i<n;i++)
        {
            int t=0;
            while(t<a.size())
            {
                int value=1;
                while(a[t]==a[t+1])//&&t+1<a.size()
                {
                    value++;
                    t++;
                }
                temp=temp+to_string(value)+a[t];//char可以直接，不用to_string
                t++;
            }
            a=temp;
            temp="";
        }
        return a;
    }
};
```

