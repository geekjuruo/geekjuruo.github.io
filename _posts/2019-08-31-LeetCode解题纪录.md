---
layout:     post                    # 使用的布局（不需要改）
title:      LeetCode洛谷解题纪录	           	# 标题 
subtitle:   OJ日记					# 副标题
date:       2019-08-31              # 时间
author:     LYH                      # 作者
header-img: img/post-bg-map.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 学习
    - 编程
    - 算法

---

## P852 山脉数组的峰顶索引

* 我们把符合下列属性的数组 A 称作山脉：

  * A.length >= 3
  * 存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]
* 给定一个确定为山脉的数组，返回任何满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] 的 i 的值。


实例：

```
输入：[0,1,0]
输出：1

输入：[0,2,1,0]
输出：1
```

### 思路

* 遍历判断即可

### Solution

```c++
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& A) {
        int ans=0;
        int len=A.size();
        for(int i=1;i<len;i++)
        {
            int j=0,k=0;
            for(j=i+1;j<len;j++)
            {
                if(A[i]<A[j])
                {break;}
            }
            
            for(k=i+1;k>=0;k--)
            {
                if(A[k]>A[i])
                {break;}
            }
            if(j==len&&k==-1)
            {
                ans=i;
                break;
            }
        }
        return ans;
    }
};
```

## P476 数字的补数

给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

**注意:**

1. 给定的整数保证在32位带符号整数的范围内。
2. 你可以假定二进制数不包含前导零位。

示例:

```
输入: 5
输出: 2
解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。

输入: 1
输出: 0
解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。
```

### 思路

* 5的二进制是：0101，7的二进制是： 0111，它们的抑或为：0010，去掉前导零位即为取反。
  再来一个例子，假设a为1110 0101，b为1111 1111，a^b = 0001 1010是a的取反。也就是说二进制位数与num相同，且全为1的数tmp与num的抑或即为所求。

### Solution

```
class Solution {
public:
    int findComplement(int num) {
        int tmp = 1;
        while (tmp < num)
        {
            tmp <<= 1;
            tmp += 1;
        }
        return (tmp^num);
    }
};
```

